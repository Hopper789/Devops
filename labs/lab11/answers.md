## Задание 2
```python3 -m http.server 8080```
Виден ли открытый порт на основной машине? Запустите сервер на ней и перезапустите
команду netstat. Виден ли в этом случае?
__Ответ: Нет. Да__

Разница между ```docker run``` и ```docker start```:
- docker start запускает остановленный контейнер. При таком запуске все файлы сохраняются и видны при каждо запуске
- docker run запускает контейнер с нуля. Эта команда включает в себя docker create и docker start

Проверим наличие файла после ```docker container prune``` и ```docker run```:
Как ожидалось, созданного файла не было

## Задание 3
```yes > file```
Обратите внимание на поля CPU и MEM USAGE. Какие значения они принимают? (100%, память постоянно растёт)
```docker run -it --memory=512m --cpus=0.5 bash```
CPU почти не выдит за пределы 50%, а память в stats ограничивается 512MB

## Задание 4
Какие интерфейсы вы видите изнутри контейнера?
__Ответ: loopback (docker run -it --rm --network none bash)__
__Ответ: loopback, eth (docker run -it --rm --network host bash)__

## Задание 5
```docker run -it --rm -v ./bindtest:/data:Z alpine```
Z нужна для мандатного контроля доступа в Fedora. 
После создания файла 

| Характеристика  | Overlay2                   | Containerd Snapshotters                              |
|-----------------|----------------------------|------------------------------------------------------|
| Где данные      | /var/lib/docker/overlay2   | /var/lib/docker/rootfs/                              |
| Управление      | Встроено в Docker Engine   | Вынесено в containerd                                |
| Btrfs / ZFS     | Имитирует слои через папки | Использует нативные снимки ФС                        |
| Возможности     | Только базовые слои        | WebAssembly, multi-platform образы, ленивая загрузка |

Для нахождения разницы я нашёл такой алгоритм:
1. ```docker diff fs-test``` - показывает разницу между базовым образом и текущим состоянием. Тут можно увидеть все изменения (A-добавление, D-удаление, C-изменение). Можно закоммитить и разница будет пустой, но она останется в ```docker history```.
2. На предыдущем шаге мы получили пути файлов, например, которые были добавлены. Мы можем найти их так ```find /var/lib/docker/rootfs -name <changed_file>``` 

## Задание 6
```
FROM alpine:latest
WORKDIR /home/student
COPY script.sh ./script.sh
RUN apk update && apk add --no-cache curl git vim
```
В результате изменения скрипта, контейнер удалил кэш всех команд, которые идут после упоминания этого скрипта в Dockerfile. Из-за чего библиотеки будут устанавливаться заново. Поэтому правильнее "долгие" команды ставить в начало, что изменение других частей Dockerfile не сильно меняло время сборки.

## Задание 7
```
docker run --rm c-single
docker run --rm c-multi
```
Вывод не отличается. Размер multi образа меньше в ~20 раз. Это связано с тем, что gcc образ включает в себя сам компилятор, библиотеки, заголовочные файлы. Из-за чего образ раздувавется, но для получения нужного результата необходим лишь бинарный файл. Поэтому мы его копируем в легковесный образ, где нет ничего лишнего.

## Задание 8
```
docker run --rm -it add-test
docker run --rm -it copy-test
```
Разница в том, что COPY протсо копирует архив, а ADD - распаковывет его (также ещё может скачивать файлы). Но скачивание через ADD считается плохой практикой, тк для удаления файла нужно будет создавать новый слой. Альтернатива RUN curl
